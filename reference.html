

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Reference &mdash; pyannote.metrics 3.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/plot_directive.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Changelog" href="changelog.html" />
    <link rel="prev" title="Command line tool" href="cli.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pyannote.metrics
          

          
          </a>

          
            
            
              <div class="version">
                3.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="api.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">Command line tool</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#evaluation-metrics">Evaluation metrics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#detection">Detection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#segmentation">Segmentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#diarization">Diarization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#optimal-vs-greedy">Optimal vs. greedy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#purity-and-coverage">Purity and coverage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-case">Use case</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#identification">Identification</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#error-analysis">Error analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plots">Plots</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyannote.metrics</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/reference.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="reference">
<h1>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h1>
<section id="evaluation-metrics">
<h2>Evaluation metrics<a class="headerlink" href="#evaluation-metrics" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
</div>
<p>Here is a typical speaker diarization pipeline:</p>
<img alt="_images/pipeline.png" src="_images/pipeline.png" />
<p>The first step is usually dedicated to speech activity detection, where the objective is to get rid of all non-speech regions.
Then, speaker change detection aims at segmenting speech regions into homogeneous segments.
The subsequent clustering step tries to group those speech segments according to the identity of the speaker.
Finally, an optional supervised classification step may be applied to actually identity every speaker cluster in a supervised way.</p>
<p>Looking at the final performance of the system is usually not enough for diagnostic purposes.
In particular, it is often necessary to evaluate the performance of each module separately to identify their strenght and weakness, or to estimate the influence of their errors on the complete pipeline.</p>
<p>Here, we provide the list of metrics that were implemented in <cite>pyannote.metrics</cite> with that very goal in mind.</p>
<p>Because manual annotations cannot be precise at the audio sample level, it is common in speaker diarization research to remove from evaluation a 500ms collar around each speaker turn boundary (250ms before and after).
Most of the metrics available in <cite>pyannote.metrics</cite> support a <cite>collar</cite> parameter, which defaults to 0.</p>
<p>Moreover, though audio files can always be processed entirely (from beginning to end), there are cases where reference annotations are only available for some regions of the audio files.
All metrics support the provision of an evaluation map that indicate which part of the audio file should be evaluated.</p>
<section id="detection">
<h3>Detection<a class="headerlink" href="#detection" title="Permalink to this headline">¶</a></h3>
<p>The two primary metrics for evaluating speech activity detection modules are detection error rate and detection cost function.</p>
<p>Detection error rate (not to be confused with diarization error rate) is defined as:</p>
<div class="math notranslate nohighlight">
\[\text{detection error rate} = \frac{\text{false alarm} + \text{missed detection}}{\text{total}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\text{false alarm}\)</span> is the duration of non-speech incorrectly classified as speech, <span class="math notranslate nohighlight">\(\text{missed detection}\)</span> is the duration of speech incorrectly classified as non-speech, and <span class="math notranslate nohighlight">\(\text{total}\)</span> is the total duration of speech in the reference.</p>
<p>Alternately, speech activity module output may be evaluated in terms of detection cost function, which is defined as:</p>
<div class="math notranslate nohighlight">
\[\text{detection cost function} = 0.25 \times \text{false alarm rate} + 0.75 \times \text{miss rate}\]</div>
<p>where <span class="math notranslate nohighlight">\(\text{false alarm rate}\)</span> is the proportion of non-speech incorrectly classified as speech and <span class="math notranslate nohighlight">\(\text{miss rate}\)</span> is the proportion of speech incorrectly classified as non-speech.</p>
<p>Additionally, detection may be evaluated in terms of accuracy (proportion of the input signal correctly classified), precision (proportion of detected speech that is speech), and recall (proporton of speech that is detected).</p>
<span class="target" id="module-pyannote.metrics.detection"></span><dl class="class">
<dt id="pyannote.metrics.detection.DetectionAccuracy">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.detection.</code><code class="sig-name descname">DetectionAccuracy</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionAccuracy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionAccuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Detection accuracy</p>
<p>This metric can be used to evaluate binary classification tasks such as
speech activity detection, for instance. Inputs are expected to only
contain segments corresponding to the positive class (e.g. speech regions).
Gaps in the inputs considered as the negative class (e.g. non-speech
regions).</p>
<p>It is computed as (tp + tn) / total, where tp is the duration of true
positive (e.g. speech classified as speech), tn is the duration of true
negative (e.g. non-speech classified as non-speech), and total is the total
duration of the input signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments (one half before, one half after).</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.detection.DetectionAccuracy.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionAccuracy.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionAccuracy.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.detection.DetectionAccuracy.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionAccuracy.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionAccuracy.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.detection.DetectionCostFunction">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.detection.</code><code class="sig-name descname">DetectionCostFunction</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">fa_weight=0.25</em>, <em class="sig-param">miss_weight=0.75</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionCostFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Detection cost function.</p>
<p>This metric can be used to evaluate binary classification tasks such as
speech activity detection. Inputs are expected to only contain segments
corresponding to the positive class (e.g. speech regions). Gaps in the
inputs considered as the negative class (e.g. non-speech regions).</p>
<p>Detection cost function (DCF), as defined by NIST for OpenSAT 2019, is
0.25*far + 0.75*missr, where far is the false alarm rate
(i.e., the proportion of non-speech incorrectly classified as speech)
and missr is the miss rate (i.e., the proportion of speech incorrectly
classified as non-speech.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments (one half before, one half after).
Defaults to 0.0.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
<li><p><strong>fa_weight</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Weight for false alarm rate.
Defaults to 0.25.</p></li>
<li><p><strong>miss_weight</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Weight for miss rate.
Defaults to 0.75.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments passed to <code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metrics.base.BaseMetric</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">References</p>
<p>“OpenSAT19 Evaluation Plan v2.” <a class="reference external" href="https://www.nist.gov/system/files/documents/2018/11/05/opensat19_evaluation_plan_v2_11-5-18.pdf">https://www.nist.gov/system/files/documents/2018/11/05/opensat19_evaluation_plan_v2_11-5-18.pdf</a></p>
<dl class="method">
<dt id="pyannote.metrics.detection.DetectionCostFunction.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionCostFunction.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionCostFunction.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.detection.DetectionCostFunction.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">components</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionCostFunction.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionCostFunction.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.detection.DetectionErrorRate">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.detection.</code><code class="sig-name descname">DetectionErrorRate</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionErrorRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionErrorRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Detection error rate</p>
<p>This metric can be used to evaluate binary classification tasks such as
speech activity detection, for instance. Inputs are expected to only
contain segments corresponding to the positive class (e.g. speech regions).
Gaps in the inputs considered as the negative class (e.g. non-speech
regions).</p>
<p>It is computed as (fa + miss) / total, where fa is the duration of false
alarm (e.g. non-speech classified as speech), miss is the duration of
missed detection (e.g. speech classified as non-speech), and total is the
total duration of the positive class in the reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments (one half before, one half after).</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.detection.DetectionErrorRate.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionErrorRate.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionErrorRate.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.detection.DetectionErrorRate.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionErrorRate.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionErrorRate.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.detection.DetectionPrecision">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.detection.</code><code class="sig-name descname">DetectionPrecision</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionPrecision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionPrecision" title="Permalink to this definition">¶</a></dt>
<dd><p>Detection precision</p>
<p>This metric can be used to evaluate binary classification tasks such as
speech activity detection, for instance. Inputs are expected to only
contain segments corresponding to the positive class (e.g. speech regions).
Gaps in the inputs considered as the negative class (e.g. non-speech
regions).</p>
<p>It is computed as tp / (tp + fp), where tp is the duration of true positive
(e.g. speech classified as speech), and fp is the duration of false
positive (e.g. non-speech classified as speech).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments (one half before, one half after).</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.detection.DetectionPrecision.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionPrecision.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionPrecision.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.detection.DetectionPrecision.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionPrecision.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionPrecision.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.detection.DetectionPrecisionRecallFMeasure">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.detection.</code><code class="sig-name descname">DetectionPrecisionRecallFMeasure</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">beta=1.0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionPrecisionRecallFMeasure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionPrecisionRecallFMeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute detection precision and recall, and return their F-score</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments (one half before, one half after).</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
<li><p><strong>beta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – When beta &gt; 1, greater importance is given to recall.
When beta &lt; 1, greater importance is given to precision.
Defaults to 1.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.metrics.detection.DetectionPrecision" title="pyannote.metrics.detection.DetectionPrecision"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metrics.detection.DetectionPrecision</span></code></a>, <a class="reference internal" href="#pyannote.metrics.detection.DetectionRecall" title="pyannote.metrics.detection.DetectionRecall"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metrics.detection.DetectionRecall</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metrics.base.f_measure</span></code></p>
</aside>
<dl class="method">
<dt id="pyannote.metrics.detection.DetectionPrecisionRecallFMeasure.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionPrecisionRecallFMeasure.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionPrecisionRecallFMeasure.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.detection.DetectionPrecisionRecallFMeasure.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionPrecisionRecallFMeasure.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionPrecisionRecallFMeasure.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.detection.DetectionRecall">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.detection.</code><code class="sig-name descname">DetectionRecall</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionRecall"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionRecall" title="Permalink to this definition">¶</a></dt>
<dd><p>Detection recall</p>
<p>This metric can be used to evaluate binary classification tasks such as
speech activity detection, for instance. Inputs are expected to only
contain segments corresponding to the positive class (e.g. speech regions).
Gaps in the inputs considered as the negative class (e.g. non-speech
regions).</p>
<p>It is computed as tp / (tp + fn), where tp is the duration of true positive
(e.g. speech classified as speech), and fn is the duration of false
negative (e.g. speech classified as non-speech).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments (one half before, one half after).</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.detection.DetectionRecall.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionRecall.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionRecall.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.detection.DetectionRecall.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/detection.html#DetectionRecall.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.detection.DetectionRecall.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="segmentation">
<h3>Segmentation<a class="headerlink" href="#segmentation" title="Permalink to this headline">¶</a></h3>
<p>Change detection modules can be evaluated using two pairs of dual metrics: precision and recall, or purity and coverage.</p>
<img alt="_images/segmentation.png" src="_images/segmentation.png" />
<p>Precision and recall are standard metrics based on the number of correctly detected speaker boundaries. Recall is 75% because 3 out of 4 reference boundaries were correctly detected, and precision is 100% because all hypothesized boundaries are correct.</p>
<p>The main weakness of that pair of metrics (and their combination into a f-score) is that it is very sensitive to the <cite>tolerance</cite> parameter, i.e. the maximum distance between two boundaries for them to be matched. From one segmentation paper to another, authors may used very different values, thus making the approaches difficult to compare.</p>
<p>Instead, we think that segment-wise purity and coverage should be used instead.
They have several advantages over precision and recall, including the fact that they do not depend on any <cite>tolerance</cite> parameter, and that they directly relate to the cluster-wise purity and coverage used for evaluating speaker diarization.</p>
<p>Segment-wise coverage is computed for each segment in the reference as the ratio of the duration of the intersection with the most co-occurring hypothesis segment and the duration of the reference segment.
For instance, coverage for reference segment 1 is 100% because it is entirely covered by hypothesis segment A.</p>
<p>Purity is the dual metric that indicates how <cite>pure</cite> hypothesis segments are. For instance, segment A is only 65% pure because it is covered at 65% by segment 1 and 35% by segment 2.</p>
<p>The final values are duration-weighted average over each segment.</p>
<span class="target" id="module-pyannote.metrics.segmentation"></span><dl class="class">
<dt id="pyannote.metrics.segmentation.SegmentationCoverage">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.segmentation.</code><code class="sig-name descname">SegmentationCoverage</code><span class="sig-paren">(</span><em class="sig-param">tolerance=0.5</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationCoverage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationCoverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Segmentation coverage</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tolerance</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – When provided, preprocess reference by filling intra-label gaps shorter
than <cite>tolerance</cite> (in seconds).</p>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.segmentation.SegmentationCoverage.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationCoverage.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationCoverage.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.segmentation.SegmentationCoverage.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationCoverage.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationCoverage.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.segmentation.SegmentationPrecision">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.segmentation.</code><code class="sig-name descname">SegmentationPrecision</code><span class="sig-paren">(</span><em class="sig-param">tolerance=0.0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationPrecision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationPrecision" title="Permalink to this definition">¶</a></dt>
<dd><p>Segmentation precision</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyannote.core</span> <span class="kn">import</span> <span class="n">Timeline</span><span class="p">,</span> <span class="n">Segment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyannote.metrics.segmentation</span> <span class="kn">import</span> <span class="n">SegmentationPrecision</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span> <span class="o">=</span> <span class="n">SegmentationPrecision</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span>
<span class="go">0.6666666666666666</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyannote.metrics.segmentation.SegmentationPrecision.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationPrecision.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationPrecision.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.segmentation.SegmentationPrecision.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationPrecision.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationPrecision.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.segmentation.SegmentationPurity">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.segmentation.</code><code class="sig-name descname">SegmentationPurity</code><span class="sig-paren">(</span><em class="sig-param">tolerance=0.5</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationPurity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationPurity" title="Permalink to this definition">¶</a></dt>
<dd><p>Segmentation purity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tolerance</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – When provided, preprocess reference by filling intra-label gaps shorter
than <cite>tolerance</cite> (in seconds).</p>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.segmentation.SegmentationPurity.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationPurity.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationPurity.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.segmentation.SegmentationPurityCoverageFMeasure">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.segmentation.</code><code class="sig-name descname">SegmentationPurityCoverageFMeasure</code><span class="sig-paren">(</span><em class="sig-param">tolerance=0.5</em>, <em class="sig-param">beta=1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationPurityCoverageFMeasure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationPurityCoverageFMeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute segmentation purity and coverage, and return their F-score.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tolerance</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – When provided, preprocess reference by filling intra-label gaps shorter
than <cite>tolerance</cite> (in seconds).</p></li>
<li><p><strong>beta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – When beta &gt; 1, greater importance is given to coverage.
When beta &lt; 1, greater importance is given to purity.
Defaults to 1.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.metrics.segmentation.SegmentationPurity" title="pyannote.metrics.segmentation.SegmentationPurity"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metrics.segmentation.SegmentationPurity</span></code></a>, <a class="reference internal" href="#pyannote.metrics.segmentation.SegmentationCoverage" title="pyannote.metrics.segmentation.SegmentationCoverage"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metrics.segmentation.SegmentationCoverage</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metrics.base.f_measure</span></code></p>
</aside>
<dl class="method">
<dt id="pyannote.metrics.segmentation.SegmentationPurityCoverageFMeasure.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationPurityCoverageFMeasure.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationPurityCoverageFMeasure.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.segmentation.SegmentationPurityCoverageFMeasure.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationPurityCoverageFMeasure.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationPurityCoverageFMeasure.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.segmentation.SegmentationRecall">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.segmentation.</code><code class="sig-name descname">SegmentationRecall</code><span class="sig-paren">(</span><em class="sig-param">tolerance=0.0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationRecall"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationRecall" title="Permalink to this definition">¶</a></dt>
<dd><p>Segmentation recall</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyannote.core</span> <span class="kn">import</span> <span class="n">Timeline</span><span class="p">,</span> <span class="n">Segment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyannote.metrics.segmentation</span> <span class="kn">import</span> <span class="n">SegmentationRecall</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">recall</span> <span class="o">=</span> <span class="n">SegmentationRecall</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">recall</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span> <span class="o">=</span> <span class="n">Timeline</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Segment</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">recall</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyannote.metrics.segmentation.SegmentationRecall.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/segmentation.html#SegmentationRecall.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.segmentation.SegmentationRecall.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="diarization">
<h3>Diarization<a class="headerlink" href="#diarization" title="Permalink to this headline">¶</a></h3>
<p>Diarization error rate (DER) is the emph{de facto} standard metric for evaluating and comparing speaker diarization systems.
It is defined as follows:</p>
<div class="math notranslate nohighlight">
\[\text{DER} = \frac{\text{false alarm} + \text{missed detection} + \text{confusion}}{\text{total}}\]</div>
<p>where <span class="math notranslate nohighlight">\(\text{false alarm}\)</span> is the duration of non-speech incorrectly classified as speech, <span class="math notranslate nohighlight">\(\text{missed detection}\)</span> is the duration of
speech incorrectly classified as non-speech, <span class="math notranslate nohighlight">\(\text{confusion}\)</span> is the duration of speaker confusion, and <span class="math notranslate nohighlight">\(\text{total}\)</span> is the sum over all speakers of their reference speech duration.</p>
<p>Note that this metric does take overlapping speech into account, potentially leading to increased missed detection in case the speaker diarization system does not include an overlapping speech detection module.</p>
<section id="optimal-vs-greedy">
<h4>Optimal vs. greedy<a class="headerlink" href="#optimal-vs-greedy" title="Permalink to this headline">¶</a></h4>
<p>Two implementations of the diarization error rate are available (optimal and greedy), depending on how the one-to-one mapping between reference and hypothesized speakers is computed.</p>
<p>The <cite>optimal</cite> version uses the Hungarian algorithm to compute the mapping that minimize the confusion term, while the <cite>greedy</cite> version operates in a greedy manner, mapping reference and hypothesized speakers iteratively, by decreasing value of their cooccurrence duration.</p>
<p>In practice, the <cite>greedy</cite> version is much faster than the <cite>optimal</cite> one, especially for files with a large number of speakers – though it may slightly over-estimate the value of the diarization error rate.</p>
</section>
<section id="purity-and-coverage">
<h4>Purity and coverage<a class="headerlink" href="#purity-and-coverage" title="Permalink to this headline">¶</a></h4>
<p>While the diarization error rate provides a convenient way to compare different diarization approaches, it is usually not enough to understand the type of errors commited by the system.</p>
<p>Purity and coverage are two dual evaluation metrics that provide additional insight on the behavior of the system.</p>
<div class="math notranslate nohighlight">
\[\begin{split} \text{purity} &amp; = &amp; \frac{\displaystyle \sum_{\text{cluster}} \max_{\text{speaker}} |\text{cluster} \cap \text{speaker}|  }{\displaystyle \sum_{\text{cluster}} |\text{cluster}|} \\
\text{coverage} &amp; = &amp; \frac{\displaystyle \sum_{\text{speaker}} \max_{\text{cluster}} |\text{speaker} \cap \text{cluster}|  }{\displaystyle \sum_{\text{speaker}} |\text{speaker}|} \\\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(|\text{speaker}|\)</span> (respectively <span class="math notranslate nohighlight">\(|\text{cluster}|\)</span>) is the speech duration of this particular reference speaker (resp. hypothesized cluster), and  <span class="math notranslate nohighlight">\(|\text{speaker} \cap \text{cluster}|\)</span> is the duration of their intersection.</p>
<p>Over-segmented results (e.g. too many speaker clusters) tend to lead to high purity and low coverage, while under-segmented results (e.g. when two speakers are merged into one large cluster) lead to low purity and higher coverage.</p>
</section>
<section id="use-case">
<h4>Use case<a class="headerlink" href="#use-case" title="Permalink to this headline">¶</a></h4>
<p>This figure depicts the evolution of a multi-stage speaker diarization system applied on the ETAPE dataset.
It is roughly made of four consecutive modules (segmentation, BIC clustering, Viterbi resegmentation, and CLR clustering).</p>
<img alt="_images/diagnostic.png" src="_images/diagnostic.png" />
<p>From the upper part of the figure (DER as a function of the module), it is clear that each module improves the output of the previous one.</p>
<p>Yet, the lower part of the figure clarifies the role of each module.
BIC clustering tends to increase the size of the speaker clusters, at the expense of purity (-7%).
Viterbi resegmentation addresses this limitation and greatly improves cluster purity (+5%), with very little impact on the actual cluster coverage (+2%).
Finally, CLR clustering brings an additional +5% coverage improvement.</p>
<span class="target" id="module-pyannote.metrics.diarization"></span><p>Metrics for diarization</p>
<dl class="class">
<dt id="pyannote.metrics.diarization.DiarizationCompleteness">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.diarization.</code><code class="sig-name descname">DiarizationCompleteness</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationCompleteness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationCompleteness" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster completeness</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.diarization.DiarizationCompleteness.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationCompleteness.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationCompleteness.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.diarization.DiarizationCoverage">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.diarization.</code><code class="sig-name descname">DiarizationCoverage</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">weighted=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationCoverage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationCoverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster coverage</p>
<p>A hypothesized annotation has perfect coverage if all segments from a
given reference label are clustered in the same cluster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weighted</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – When True (default), each cluster is weighted by its overall duration.</p></li>
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.diarization.DiarizationCoverage.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationCoverage.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationCoverage.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.diarization.DiarizationErrorRate">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.diarization.</code><code class="sig-name descname">DiarizationErrorRate</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationErrorRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationErrorRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Diarization error rate</p>
<p>First, the optimal mapping between reference and hypothesis labels
is obtained using the Hungarian algorithm. Then, the actual diarization
error rate is computed as the identification error rate with each hypothesis
label translated into the corresponding reference label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
<li><p><strong>Usage</strong> – </p></li>
<li><p><strong>-----</strong> – </p></li>
<li><p><strong>Diarization error rate between reference and hypothesis annotations</strong> (<em>*</em>) – <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metric</span> <span class="o">=</span> <span class="n">DiarizationErrorRate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>           
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>          
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span> 
</pre></div>
</div>
</p></li>
<li><p><strong>Compute global diarization error rate and confidence interval</strong> (<em>*</em>) – <p>over multiple documents</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span> <span class="ow">in</span> <span class="o">...</span>      
<span class="gp">... </span>   <span class="n">metric</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span>      
<span class="gp">&gt;&gt;&gt; </span><span class="n">global_value</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>            
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">,</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">confidence_interval</span><span class="p">()</span> 
</pre></div>
</div>
</p></li>
<li><p><strong>Get diarization error rate detailed components</strong> (<em>*</em>) – <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">components</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">,</span> <span class="n">detailed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#doctest +SKIP</span>
</pre></div>
</div>
</p></li>
<li><p><strong>Get accumulated components</strong> (<em>*</em>) – <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">components</span> <span class="o">=</span> <span class="n">metric</span><span class="p">[:]</span>                
<span class="gp">&gt;&gt;&gt; </span><span class="n">metric</span><span class="p">[</span><span class="s1">&#39;confusion&#39;</span><span class="p">]</span>                   
</pre></div>
</div>
</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metric.base.BaseMetric</span></code></dt><dd><p>details on accumulation</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metric.identification.IdentificationErrorRate</span></code></dt><dd><p>identification error rate</p>
</dd>
</dl>
</aside>
<dl class="method">
<dt id="pyannote.metrics.diarization.DiarizationErrorRate.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationErrorRate.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationErrorRate.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Override self.collar</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Override self.skip_overlap</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metric.diarization.DiarizationErrorRate</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">two()</span></code></p>
</aside>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.diarization.DiarizationErrorRate.optimal_mapping">
<code class="sig-name descname">optimal_mapping</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationErrorRate.optimal_mapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationErrorRate.optimal_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimal label mapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>Annotation</em>) – </p></li>
<li><p><strong>hypothesis</strong> (<em>Annotation</em>) – Reference and hypothesis diarization</p></li>
<li><p><strong>uem</strong> (<em>Timeline</em>) – Evaluation map</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mapping</strong> – Mapping between hypothesis (key) and reference (value) labels</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.diarization.DiarizationHomogeneity">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.diarization.</code><code class="sig-name descname">DiarizationHomogeneity</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationHomogeneity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationHomogeneity" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster homogeneity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.diarization.DiarizationHomogeneity.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationHomogeneity.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationHomogeneity.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.diarization.DiarizationHomogeneity.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationHomogeneity.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationHomogeneity.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.diarization.DiarizationPurity">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.diarization.</code><code class="sig-name descname">DiarizationPurity</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">weighted=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationPurity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationPurity" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster purity</p>
<p>A hypothesized annotation has perfect purity if all of its labels overlap
only segments which are members of a single reference label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weighted</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – When True (default), each cluster is weighted by its overall duration.</p></li>
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.diarization.DiarizationPurity.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationPurity.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationPurity.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.diarization.DiarizationPurity.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationPurity.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationPurity.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.diarization.DiarizationPurityCoverageFMeasure">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.diarization.</code><code class="sig-name descname">DiarizationPurityCoverageFMeasure</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">weighted=True</em>, <em class="sig-param">beta=1.0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationPurityCoverageFMeasure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationPurityCoverageFMeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute diarization purity and coverage, and return their F-score.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weighted</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – When True (default), each cluster/class is weighted by its overall
duration.</p></li>
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
<li><p><strong>beta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – When beta &gt; 1, greater importance is given to coverage.
When beta &lt; 1, greater importance is given to purity.
Defaults to 1.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pyannote.metrics.diarization.DiarizationPurity" title="pyannote.metrics.diarization.DiarizationPurity"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metrics.diarization.DiarizationPurity</span></code></a>, <a class="reference internal" href="#pyannote.metrics.diarization.DiarizationCoverage" title="pyannote.metrics.diarization.DiarizationCoverage"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metrics.diarization.DiarizationCoverage</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metrics.base.f_measure</span></code></p>
</aside>
<dl class="method">
<dt id="pyannote.metrics.diarization.DiarizationPurityCoverageFMeasure.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationPurityCoverageFMeasure.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationPurityCoverageFMeasure.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.diarization.DiarizationPurityCoverageFMeasure.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#DiarizationPurityCoverageFMeasure.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.DiarizationPurityCoverageFMeasure.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.diarization.GreedyDiarizationErrorRate">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.diarization.</code><code class="sig-name descname">GreedyDiarizationErrorRate</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#GreedyDiarizationErrorRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.GreedyDiarizationErrorRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Greedy diarization error rate</p>
<p>First, the greedy mapping between reference and hypothesis labels is
obtained. Then, the actual diarization error rate is computed as the
identification error rate with each hypothesis label translated into the
corresponding reference label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
<li><p><strong>Usage</strong> – </p></li>
<li><p><strong>-----</strong> – </p></li>
<li><p><strong>Greedy diarization error rate between reference and hypothesis annotations</strong> (<em>*</em>) – <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metric</span> <span class="o">=</span> <span class="n">GreedyDiarizationErrorRate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>           
<span class="gp">&gt;&gt;&gt; </span><span class="n">hypothesis</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>          
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span> 
</pre></div>
</div>
</p></li>
<li><p><strong>Compute global greedy diarization error rate and confidence interval</strong> (<em>*</em>) – <p>over multiple documents</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span> <span class="ow">in</span> <span class="o">...</span>      
<span class="gp">... </span>   <span class="n">metric</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span>      
<span class="gp">&gt;&gt;&gt; </span><span class="n">global_value</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>            
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">,</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">confidence_interval</span><span class="p">()</span> 
</pre></div>
</div>
</p></li>
<li><p><strong>Get greedy diarization error rate detailed components</strong> (<em>*</em>) – <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">components</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">,</span> <span class="n">detailed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#doctest +SKIP</span>
</pre></div>
</div>
</p></li>
<li><p><strong>Get accumulated components</strong> (<em>*</em>) – <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">components</span> <span class="o">=</span> <span class="n">metric</span><span class="p">[:]</span>                
<span class="gp">&gt;&gt;&gt; </span><span class="n">metric</span><span class="p">[</span><span class="s1">&#39;confusion&#39;</span><span class="p">]</span>                   
</pre></div>
</div>
</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metric.base.BaseMetric</span></code></dt><dd><p>details on accumulation</p>
</dd>
</dl>
</aside>
<dl class="method">
<dt id="pyannote.metrics.diarization.GreedyDiarizationErrorRate.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#GreedyDiarizationErrorRate.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.GreedyDiarizationErrorRate.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Override self.collar</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Override self.skip_overlap</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metric.diarization.DiarizationErrorRate</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">two()</span></code></p>
</aside>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.diarization.GreedyDiarizationErrorRate.greedy_mapping">
<code class="sig-name descname">greedy_mapping</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#GreedyDiarizationErrorRate.greedy_mapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.GreedyDiarizationErrorRate.greedy_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Greedy label mapping</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>Annotation</em>) – </p></li>
<li><p><strong>hypothesis</strong> (<em>Annotation</em>) – Reference and hypothesis diarization</p></li>
<li><p><strong>uem</strong> (<em>Timeline</em>) – Evaluation map</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mapping</strong> – Mapping between hypothesis (key) and reference (value) labels</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.diarization.JaccardErrorRate">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.diarization.</code><code class="sig-name descname">JaccardErrorRate</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#JaccardErrorRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.JaccardErrorRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Jaccard error rate</p>
<p>Second DIHARD Challenge Evaluation Plan. Version 1.1
N. Ryant, K. Church, C. Cieri, A. Cristia, J. Du, S. Ganapathy, M. Liberman
<a class="reference external" href="https://coml.lscp.ens.fr/dihard/2019/second_dihard_eval_plan_v1.1.pdf">https://coml.lscp.ens.fr/dihard/2019/second_dihard_eval_plan_v1.1.pdf</a></p>
<p>“The Jaccard error rate is based on the Jaccard index, a similarity measure
used to evaluate the output of image segmentation systems. An optimal
mapping between reference and system speakers is determined and for each
pair the Jaccard index is computed. The Jaccard error rate is then defined
as 1 minus the average of these scores. While similar to DER, it weights
every speaker’s contribution equally, regardless of how much speech they
actually produced.</p>
<p>More concretely, assume we have N reference speakers and M system speakers.
An optimal mapping between speakers is determined using the Hungarian
algorithm so that each reference speaker is paired with at most one system
speaker and each system speaker with at most one reference speaker. Then,
for each reference speaker ref the speaker-specific Jaccard error rate
JERref is computed as JERref = (FA + MISS) / TOTAL where</p>
<blockquote>
<div><ul class="simple">
<li><p>TOTAL is the duration of the union of reference and system speaker</p></li>
</ul>
<p>segments; if the reference speaker was not paired with a system
speaker, it is the duration of all reference speaker segments
* FA is the total system speaker time not attributed to the reference
speaker; if the reference speaker was not paired with a system speaker,
it is 0
* MISS is the total reference speaker time not attributed to the system
speaker; if the reference speaker was not paired with a system speaker,
it is equal to TOTAL</p>
</div></blockquote>
<p>The Jaccard error rate then is the average of the speaker specific Jaccard
error rates.</p>
<p>JER and DER are highly correlated with JER typically being higher,
especially in recordings where one or more speakers is particularly
dominant. Where it tends to track DER is in outliers where the diarization
is especially bad, resulting in one or more unmapped system speakers whose
speech is not then penalized. In these cases, where DER can easily exceed
500%, JER will never exceed 100% and may be far lower if the reference
speakers are handled correctly.”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
<li><p><strong>Usage</strong> – </p></li>
<li><p><strong>-----</strong> – </p></li>
<li><p><strong>metric = JaccardErrorRate</strong><strong>(</strong><strong>)</strong> (<em>&gt;&gt;&gt;</em>) – </p></li>
<li><p><strong>reference = Annotation</strong><strong>(</strong><strong>..</strong><strong>)           </strong><strong># doctest</strong> (<em>&gt;&gt;&gt;</em>) – </p></li>
<li><p><strong>hypothesis = Annotation</strong><strong>(</strong><strong>..</strong><strong>)          </strong><strong># doctest</strong> (<em>&gt;&gt;&gt;</em>) – </p></li>
<li><p><strong>jer = metric</strong><strong>(</strong><strong>reference</strong><strong>, </strong><strong>hypothesis</strong><strong>)   </strong><strong># doctest</strong> (<em>&gt;&gt;&gt;</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.diarization.JaccardErrorRate.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#JaccardErrorRate.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.JaccardErrorRate.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Override self.collar</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Override self.skip_overlap</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metric.diarization.DiarizationErrorRate</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">two()</span></code></p>
</aside>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.diarization.JaccardErrorRate.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/diarization.html#JaccardErrorRate.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.diarization.JaccardErrorRate.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyannote.metrics.matcher"></span><dl class="class">
<dt id="pyannote.metrics.matcher.LabelMatcher">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.matcher.</code><code class="sig-name descname">LabelMatcher</code><a class="reference internal" href="_modules/pyannote/metrics/matcher.html#LabelMatcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.matcher.LabelMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>ID matcher base class.</p>
<p>All ID matcher classes must inherit from this class and implement
.match() – ie return True if two IDs match and False
otherwise.</p>
<dl class="method">
<dt id="pyannote.metrics.matcher.LabelMatcher.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">rlabel</em>, <em class="sig-param">hlabel</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/matcher.html#LabelMatcher.match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.matcher.LabelMatcher.match" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rlabel</strong> – Reference label</p></li>
<li><p><strong>hlabel</strong> – Hypothesis label</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>match</strong> – True if labels match, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)">bool</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="identification">
<h3>Identification<a class="headerlink" href="#identification" title="Permalink to this headline">¶</a></h3>
<p>In case prior speaker models are available, the speech turn clustering module may be followed by a supervised speaker recognition module for cluster-wise supervised classification.</p>
<p><cite>pyannote.metrics</cite> also provides a collection of evaluation metrics for this identification task. This includes precision, recall, and identification error rate (IER):</p>
<div class="math notranslate nohighlight">
\[\text{IER} = \frac{\text{false alarm} + \text{missed detection} + \text{confusion}}{\text{total}}\]</div>
<p>which is similar to the diarization error rate (DER) introduced previously, except that the <span class="math notranslate nohighlight">\(\texttt{confusion}\)</span> term is computed directly by comparing reference and hypothesis labels, and does not rely on a prior one-to-one matching.</p>
<span class="target" id="module-pyannote.metrics.identification"></span><dl class="class">
<dt id="pyannote.metrics.identification.IdentificationErrorRate">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.identification.</code><code class="sig-name descname">IdentificationErrorRate</code><span class="sig-paren">(</span><em class="sig-param">confusion=1.0</em>, <em class="sig-param">miss=1.0</em>, <em class="sig-param">false_alarm=1.0</em>, <em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/identification.html#IdentificationErrorRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.identification.IdentificationErrorRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Identification error rate</p>
<p><code class="docutils literal notranslate"><span class="pre">ier</span> <span class="pre">=</span> <span class="pre">(wc</span> <span class="pre">x</span> <span class="pre">confusion</span> <span class="pre">+</span> <span class="pre">wf</span> <span class="pre">x</span> <span class="pre">false_alarm</span> <span class="pre">+</span> <span class="pre">wm</span> <span class="pre">x</span> <span class="pre">miss)</span> <span class="pre">/</span> <span class="pre">total</span></code></p>
<dl class="simple">
<dt>where</dt><dd><ul class="simple">
<li><p><cite>confusion</cite> is the total confusion duration in seconds</p></li>
<li><p><cite>false_alarm</cite> is the total hypothesis duration where there are</p></li>
<li><p><cite>miss</cite> is</p></li>
<li><p><cite>total</cite> is the total duration of all tracks</p></li>
<li><p>wc, wf and wm are optional weights (default to 1)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
<li><p><strong>miss</strong><strong>, </strong><strong>false_alarm</strong> (<em>confusion</em><em>,</em>) – Optional weights for confusion, miss and false alarm respectively.
Default to 1. (no weight)</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.identification.IdentificationErrorRate.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">collar=None</em>, <em class="sig-param">skip_overlap=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/identification.html#IdentificationErrorRate.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.identification.IdentificationErrorRate.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Override self.collar</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Override self.skip_overlap</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">pyannote.metric.diarization.DiarizationErrorRate</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">two()</span></code></p>
</aside>
</dd></dl>

<dl class="method">
<dt id="pyannote.metrics.identification.IdentificationErrorRate.compute_metric">
<code class="sig-name descname">compute_metric</code><span class="sig-paren">(</span><em class="sig-param">detail</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/identification.html#IdentificationErrorRate.compute_metric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.identification.IdentificationErrorRate.compute_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric value from computed <cite>components</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>components</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><em>dict</em></a>) – Dictionary where keys are components names and values are component
values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>value</strong> – Metric value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>type depends on the metric</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.identification.IdentificationPrecision">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.identification.</code><code class="sig-name descname">IdentificationPrecision</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/identification.html#IdentificationPrecision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.identification.IdentificationPrecision" title="Permalink to this definition">¶</a></dt>
<dd><p>Identification Precision</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.identification.IdentificationPrecision.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/identification.html#IdentificationPrecision.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.identification.IdentificationPrecision.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyannote.metrics.identification.IdentificationRecall">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.identification.</code><code class="sig-name descname">IdentificationRecall</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/identification.html#IdentificationRecall"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.identification.IdentificationRecall" title="Permalink to this definition">¶</a></dt>
<dd><p>Identification Recall</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.identification.IdentificationRecall.compute_components">
<code class="sig-name descname">compute_components</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/identification.html#IdentificationRecall.compute_components"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.identification.IdentificationRecall.compute_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute metric components</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reference</strong> (<em>type depends on the metric</em>) – Manual <cite>reference</cite></p></li>
<li><p><strong>hypothesis</strong> (same as <cite>reference</cite>) – Evaluated <cite>hypothesis</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>components</strong> – Dictionary where keys are component names and values are component
values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)">dict</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="error-analysis">
<h2>Error analysis<a class="headerlink" href="#error-analysis" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pyannote.metrics.errors.segmentation"></span><span class="target" id="module-pyannote.metrics.errors.identification"></span><dl class="class">
<dt id="pyannote.metrics.errors.identification.IdentificationErrorAnalysis">
<em class="property">class </em><code class="sig-prename descclassname">pyannote.metrics.errors.identification.</code><code class="sig-name descname">IdentificationErrorAnalysis</code><span class="sig-paren">(</span><em class="sig-param">collar=0.0</em>, <em class="sig-param">skip_overlap=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/errors/identification.html#IdentificationErrorAnalysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.errors.identification.IdentificationErrorAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)"><em>float</em></a><em>, </em><em>optional</em>) – Duration (in seconds) of collars removed from evaluation around
boundaries of reference segments.</p></li>
<li><p><strong>skip_overlap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True to not evaluate overlap regions.
Defaults to False (i.e. keep overlap regions).</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pyannote.metrics.errors.identification.IdentificationErrorAnalysis.difference">
<code class="sig-name descname">difference</code><span class="sig-paren">(</span><em class="sig-param">reference</em>, <em class="sig-param">hypothesis</em>, <em class="sig-param">uem=None</em>, <em class="sig-param">uemified=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/errors/identification.html#IdentificationErrorAnalysis.difference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.errors.identification.IdentificationErrorAnalysis.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Get error analysis as <cite>Annotation</cite></p>
<p>Labels are (status, reference_label, hypothesis_label) tuples.
<cite>status</cite> is either ‘correct’, ‘confusion’, ‘missed detection’ or
‘false alarm’.
<cite>reference_label</cite> is None in case of ‘false alarm’.
<cite>hypothesis_label</cite> is None in case of ‘missed detection’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>uemified</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a><em>, </em><em>optional</em>) – Returns “uemified” version of reference and hypothesis.
Defaults to False.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>errors</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Annotation</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="plots">
<h2>Plots<a class="headerlink" href="#plots" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pyannote.metrics.plot.binary_classification"></span><dl class="function">
<dt id="pyannote.metrics.plot.binary_classification.plot_det_curve">
<code class="sig-prename descclassname">pyannote.metrics.plot.binary_classification.</code><code class="sig-name descname">plot_det_curve</code><span class="sig-paren">(</span><em class="sig-param">y_true</em>, <em class="sig-param">scores</em>, <em class="sig-param">save_to</em>, <em class="sig-param">distances=False</em>, <em class="sig-param">dpi=150</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/plot/binary_classification.html#plot_det_curve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.plot.binary_classification.plot_det_curve" title="Permalink to this definition">¶</a></dt>
<dd><p>DET curve</p>
<dl class="simple">
<dt>This function will create (and overwrite) the following files:</dt><dd><ul class="simple">
<li><p>{save_to}.det.png</p></li>
<li><p>{save_to}.det.eps</p></li>
<li><p>{save_to}.det.txt</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> (<em>(</em><em>n_samples</em><em>, </em><em>) </em><em>array-like</em>) – Boolean reference.</p></li>
<li><p><strong>scores</strong> (<em>(</em><em>n_samples</em><em>, </em><em>) </em><em>array-like</em>) – Predicted score.</p></li>
<li><p><strong>save_to</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Files path prefix.</p></li>
<li><p><strong>distances</strong> (<em>boolean</em><em>, </em><em>optional</em>) – When True, indicate that <cite>scores</cite> are actually <cite>distances</cite></p></li>
<li><p><strong>dpi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Resolution of .png file. Defaults to 150.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>eer</strong> – Equal error rate</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyannote.metrics.plot.binary_classification.plot_distributions">
<code class="sig-prename descclassname">pyannote.metrics.plot.binary_classification.</code><code class="sig-name descname">plot_distributions</code><span class="sig-paren">(</span><em class="sig-param">y_true</em>, <em class="sig-param">scores</em>, <em class="sig-param">save_to</em>, <em class="sig-param">xlim=None</em>, <em class="sig-param">nbins=100</em>, <em class="sig-param">ymax=3.0</em>, <em class="sig-param">dpi=150</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/plot/binary_classification.html#plot_distributions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.plot.binary_classification.plot_distributions" title="Permalink to this definition">¶</a></dt>
<dd><p>Scores distributions</p>
<dl class="simple">
<dt>This function will create (and overwrite) the following files:</dt><dd><ul class="simple">
<li><p>{save_to}.scores.png</p></li>
<li><p>{save_to}.scores.eps</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> (<em>(</em><em>n_samples</em><em>, </em><em>) </em><em>array-like</em>) – Boolean reference.</p></li>
<li><p><strong>scores</strong> (<em>(</em><em>n_samples</em><em>, </em><em>) </em><em>array-like</em>) – Predicted score.</p></li>
<li><p><strong>save_to</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Files path prefix</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyannote.metrics.plot.binary_classification.plot_precision_recall_curve">
<code class="sig-prename descclassname">pyannote.metrics.plot.binary_classification.</code><code class="sig-name descname">plot_precision_recall_curve</code><span class="sig-paren">(</span><em class="sig-param">y_true</em>, <em class="sig-param">scores</em>, <em class="sig-param">save_to</em>, <em class="sig-param">distances=False</em>, <em class="sig-param">dpi=150</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyannote/metrics/plot/binary_classification.html#plot_precision_recall_curve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyannote.metrics.plot.binary_classification.plot_precision_recall_curve" title="Permalink to this definition">¶</a></dt>
<dd><p>Precision/recall curve</p>
<dl class="simple">
<dt>This function will create (and overwrite) the following files:</dt><dd><ul class="simple">
<li><p>{save_to}.precision_recall.png</p></li>
<li><p>{save_to}.precision_recall.eps</p></li>
<li><p>{save_to}.precision_recall.txt</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_true</strong> (<em>(</em><em>n_samples</em><em>, </em><em>) </em><em>array-like</em>) – Boolean reference.</p></li>
<li><p><strong>scores</strong> (<em>(</em><em>n_samples</em><em>, </em><em>) </em><em>array-like</em>) – Predicted score.</p></li>
<li><p><strong>save_to</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><em>str</em></a>) – Files path prefix.</p></li>
<li><p><strong>distances</strong> (<em>boolean</em><em>, </em><em>optional</em>) – When True, indicate that <cite>scores</cite> are actually <cite>distances</cite></p></li>
<li><p><strong>dpi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><em>int</em></a><em>, </em><em>optional</em>) – Resolution of .png file. Defaults to 150.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>auc</strong> – Area under precision/recall curve</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.10)">float</a></p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="changelog.html" class="btn btn-neutral float-right" title="Changelog" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cli.html" class="btn btn-neutral float-left" title="Command line tool" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, CNRS

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>